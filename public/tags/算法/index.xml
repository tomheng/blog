<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on 趣味互联网</title>
    <link>http://:1313/tmp/tags/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on 趣味互联网</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 02 Dec 2012 13:17:59 +0000</lastBuildDate>
    <atom:link href="http://:1313/tmp/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>【转】SkipList 跳表</title>
      <link>http://:1313/tmp/2012/12/%E8%BD%ACskiplist-%E8%B7%B3%E8%A1%A8/</link>
      <pubDate>Sun, 02 Dec 2012 13:17:59 +0000</pubDate>
      
      <guid>http://:1313/tmp/2012/12/%E8%BD%ACskiplist-%E8%B7%B3%E8%A1%A8/</guid>
      <description>

&lt;h4 id=&#34;为什么选择跳表:2f6491a9cf8eb1ad32d8060eb72d28bc&#34;&gt;为什么选择跳表&lt;/h4&gt;

&lt;p&gt;目前经常使用的平衡数据结构有：B树，红黑树，AVL树，Splay Tree, Treep等。&lt;/p&gt;

&lt;p&gt;想象一下，给你一张草稿纸，一只笔，一个编辑器，你能立即实现一颗红黑树，或者AVL树&lt;/p&gt;

&lt;p&gt;出来吗？ 很难吧，这需要时间，要考虑很多细节，要参考一堆算法与数据结构之类的书，&lt;/p&gt;

&lt;p&gt;还要参考网上的代码，相当麻烦。&lt;/p&gt;

&lt;p&gt;用跳表吧，跳表是一种随机化的数据结构，目前开源软件 Redis 和 LevelDB 都有用到它，&lt;/p&gt;

&lt;p&gt;它的效率和红黑树以及 AVL 树不相上下，但跳表的原理相当简单，只要你能熟练操作链表，&lt;/p&gt;

&lt;p&gt;就能轻松实现一个 SkipList。&lt;/p&gt;

&lt;h4 id=&#34;有序表的搜索:2f6491a9cf8eb1ad32d8060eb72d28bc&#34;&gt;有序表的搜索&lt;/h4&gt;

&lt;p&gt;考虑一个有序表：&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1584&#34; title=&#34;d5d03b36-abff-34ea-9c40-a1fbfb709a81&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/12/d5d03b36-abff-34ea-9c40-a1fbfb709a811.jpg&#34; alt=&#34;&#34; width=&#34;461&#34; height=&#34;52&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从该有序表中搜索元素 &amp;lt; 23, 43, 59 &amp;gt; ，需要比较的次数分别为 &amp;lt; 2, 4, 6 &amp;gt;，总共比较的次数&lt;/p&gt;

&lt;p&gt;为 2 + 4 + 6 = 12 次。有没有优化的算法吗?  链表是有序的，但不能使用二分查找。类似二叉&lt;/p&gt;

&lt;p&gt;搜索树，我们把一些节点提取出来，作为索引。得到如下结构：&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1586&#34; title=&#34;7c904c3f-1f39-31af-b8cd-b6de27a94061&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/12/7c904c3f-1f39-31af-b8cd-b6de27a940611.jpg&#34; alt=&#34;&#34; width=&#34;464&#34; height=&#34;108&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们把 &amp;lt; 14, 34, 50, 72 &amp;gt; 提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。&lt;/p&gt;

&lt;p&gt;我们还可以再从一级索引提取一些元素出来，作为二级索引，变成如下结构：&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1587&#34; title=&#34;96983cb0-d60a-31da-953d-2dde4036ea6b&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/12/96983cb0-d60a-31da-953d-2dde4036ea6b.jpg&#34; alt=&#34;&#34; width=&#34;479&#34; height=&#34;192&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里元素不多，体现不出优势，如果元素足够多，这种索引结构就能体现出优势来了。&lt;/p&gt;

&lt;h4 id=&#34;跳表:2f6491a9cf8eb1ad32d8060eb72d28bc&#34;&gt;跳表&lt;/h4&gt;

&lt;p&gt;下面的结构是就是跳表：&lt;/p&gt;

&lt;p&gt;其中 -1 表示 INT_MIN， 链表的最小值，1 表示 INT_MAX，链表的最大值。&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  &lt;img class=&#34;aligncenter  wp-image-1588&#34; title=&#34;f4c149bd-d8ea-39ff-813f-93d809c90966&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/12/f4c149bd-d8ea-39ff-813f-93d809c90966.jpg&#34; alt=&#34;&#34; width=&#34;620&#34; height=&#34;206&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;跳表具有如下性质：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(1) 由很多层结构组成&lt;/p&gt;

&lt;p&gt;(2) 每一层都是一个有序的链表&lt;/p&gt;

&lt;p&gt;(3) 最底层(Level 1)的链表包含所有元素&lt;/p&gt;

&lt;p&gt;(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。&lt;/p&gt;

&lt;p&gt;(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。&lt;/p&gt;

&lt;h4 id=&#34;跳表的搜索:2f6491a9cf8eb1ad32d8060eb72d28bc&#34;&gt;跳表的搜索&lt;/h4&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  &lt;img class=&#34;aligncenter  wp-image-1589&#34; title=&#34;ec9fd643-f85c-3072-8634-60cfc88ab334&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/12/ec9fd643-f85c-3072-8634-60cfc88ab334.jpg&#34; alt=&#34;&#34; width=&#34;622&#34; height=&#34;179&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;例子：查找元素 117&lt;/p&gt;

&lt;p&gt;(1) 比较 21， 比 21 大，往后面找&lt;/p&gt;

&lt;p&gt;(2) 比较 37,   比 37大，比链表最大值小，从 37 的下面一层开始找&lt;/p&gt;

&lt;p&gt;(3) 比较 71,  比 71 大，比链表最大值小，从 71 的下面一层开始找&lt;/p&gt;

&lt;p&gt;(4) 比较 85， 比 85 大，从后面找&lt;/p&gt;

&lt;p&gt;(5) 比较 117， 等于 117， 找到了节点。&lt;/p&gt;

&lt;p&gt;具体的搜索算法如下&lt;/p&gt;

&lt;div class=&#34;codecolorer-container c blackboard&#34; style=&#34;overflow:auto;white-space:nowrap;&#34;&gt;
  &lt;table cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;
    &lt;tr&gt;
      &lt;td class=&#34;line-numbers&#34;&gt;
        &lt;div&gt;
          1&lt;br /&gt;2&lt;br /&gt;3&lt;br /&gt;4&lt;br /&gt;5&lt;br /&gt;6&lt;br /&gt;7&lt;br /&gt;8&lt;br /&gt;9&lt;br /&gt;10&lt;br /&gt;11&lt;br /&gt;12&lt;br /&gt;13&lt;br /&gt;
        &lt;/div&gt;
      &lt;/td&gt;
      
      &lt;td&gt;
        &lt;div class=&#34;c codecolorer&#34;&gt;
          &lt;span class=&#34;coMULTI&#34;&gt;/* 如果存在 x, 返回 x 所在的节点， &lt;br /&gt; &amp;nbsp;* 否则返回 x 的后继节点 */&lt;/span&gt; &amp;nbsp;&lt;br /&gt; find&lt;span class=&#34;br0&#34;&gt;&amp;#40;&lt;/span&gt;x&lt;span class=&#34;br0&#34;&gt;&amp;#41;&lt;/span&gt; &amp;nbsp; &lt;br /&gt; &lt;span class=&#34;br0&#34;&gt;&amp;#123;&lt;/span&gt; &amp;nbsp;&lt;br /&gt; &amp;nbsp; &amp;nbsp; p &lt;span class=&#34;sy0&#34;&gt;=&lt;/span&gt; top&lt;span class=&#34;sy0&#34;&gt;;&lt;/span&gt; &amp;nbsp;&lt;br /&gt; &amp;nbsp; &amp;nbsp; &lt;span class=&#34;kw1&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;br0&#34;&gt;&amp;#40;&lt;/span&gt;&lt;span class=&#34;nu0&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;br0&#34;&gt;&amp;#41;&lt;/span&gt; &lt;span class=&#34;br0&#34;&gt;&amp;#123;&lt;/span&gt; &amp;nbsp;&lt;br /&gt; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;span class=&#34;kw1&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;br0&#34;&gt;&amp;#40;&lt;/span&gt;p&lt;span class=&#34;sy0&#34;&gt;-&gt;&lt;/span&gt;next&lt;span class=&#34;sy0&#34;&gt;-&gt;&lt;/span&gt;key &lt;span class=&#34;sy0&#34;&gt;&lt;&lt;/span&gt; x&lt;span class=&#34;br0&#34;&gt;&amp;#41;&lt;/span&gt; &amp;nbsp;&lt;br /&gt; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; p &lt;span class=&#34;sy0&#34;&gt;=&lt;/span&gt; p&lt;span class=&#34;sy0&#34;&gt;-&gt;&lt;/span&gt;next&lt;span class=&#34;sy0&#34;&gt;;&lt;/span&gt; &amp;nbsp;&lt;br /&gt; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;span class=&#34;kw1&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;br0&#34;&gt;&amp;#40;&lt;/span&gt;p&lt;span class=&#34;sy0&#34;&gt;-&gt;&lt;/span&gt;down &lt;span class=&#34;sy0&#34;&gt;==&lt;/span&gt; NULL&lt;span class=&#34;br0&#34;&gt;&amp;#41;&lt;/span&gt; &amp;nbsp; &lt;br /&gt; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;span class=&#34;kw1&#34;&gt;return&lt;/span&gt; p&lt;span class=&#34;sy0&#34;&gt;-&gt;&lt;/span&gt;next&lt;span class=&#34;sy0&#34;&gt;;&lt;/span&gt; &amp;nbsp;&lt;br /&gt; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; p &lt;span class=&#34;sy0&#34;&gt;=&lt;/span&gt; p&lt;span class=&#34;sy0&#34;&gt;-&gt;&lt;/span&gt;down&lt;span class=&#34;sy0&#34;&gt;;&lt;/span&gt; &amp;nbsp;&lt;br /&gt; &amp;nbsp; &amp;nbsp; &lt;span class=&#34;br0&#34;&gt;&amp;#125;&lt;/span&gt; &amp;nbsp;&lt;br /&gt; &lt;span class=&#34;br0&#34;&gt;&amp;#125;&lt;/span&gt;
        &lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;

&lt;h4 id=&#34;跳表的插入:2f6491a9cf8eb1ad32d8060eb72d28bc&#34;&gt;跳表的插入&lt;/h4&gt;

&lt;p&gt;先确定该元素要占据的层数 K（采用丢硬币的方式，这完全是随机的）&lt;/p&gt;

&lt;p&gt;然后在 Level 1 &amp;#8230; Level K 各个层的链表都插入元素。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;text-align: center;&#34;&gt;例子：插入 119， K = 2&lt;/span&gt;&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  &lt;img class=&#34;aligncenter  wp-image-1591&#34; title=&#34;bb72be16-6162-3fee-b680-311f25dd7c3a&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/12/bb72be16-6162-3fee-b680-311f25dd7c3a1.jpg&#34; alt=&#34;&#34; width=&#34;626&#34; height=&#34;177&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;如果 K 大于链表的层数，则要添加新的层。&lt;/p&gt;

&lt;p&gt;例子：插入 119， K = 4&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  &lt;img class=&#34;aligncenter  wp-image-1593&#34; title=&#34;6eac083f-45d9-37f9-867f-0d709d9659d3&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/12/6eac083f-45d9-37f9-867f-0d709d9659d31.jpg&#34; alt=&#34;&#34; width=&#34;625&#34; height=&#34;194&#34; /&gt;
&lt;/p&gt;

&lt;h4 id=&#34;丢硬币决定-k:2f6491a9cf8eb1ad32d8060eb72d28bc&#34;&gt;丢硬币决定 K&lt;/h4&gt;

&lt;p&gt;插入元素的时候，元素所占有的层数完全是随机的，通过一下随机算法产生：&lt;/p&gt;

&lt;div class=&#34;codecolorer-container c blackboard&#34; style=&#34;overflow:auto;white-space:nowrap;&#34;&gt;
  &lt;table cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;
    &lt;tr&gt;
      &lt;td class=&#34;line-numbers&#34;&gt;
        &lt;div&gt;
          1&lt;br /&gt;2&lt;br /&gt;3&lt;br /&gt;4&lt;br /&gt;5&lt;br /&gt;6&lt;br /&gt;7&lt;br /&gt;8&lt;br /&gt;9&lt;br /&gt;
        &lt;/div&gt;
      &lt;/td&gt;
      
      &lt;td&gt;
        &lt;div class=&#34;c codecolorer&#34;&gt;
          &lt;span class=&#34;kw4&#34;&gt;int&lt;/span&gt; random_level&lt;span class=&#34;br0&#34;&gt;&amp;#40;&lt;/span&gt;&lt;span class=&#34;br0&#34;&gt;&amp;#41;&lt;/span&gt;&lt;br /&gt; &lt;span class=&#34;br0&#34;&gt;&amp;#123;&lt;/span&gt;&lt;br /&gt; K &lt;span class=&#34;sy0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;sy0&#34;&gt;;&lt;/span&gt; &lt;br /&gt; &lt;br /&gt; &lt;span class=&#34;kw1&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;br0&#34;&gt;&amp;#40;&lt;/span&gt;random&lt;span class=&#34;br0&#34;&gt;&amp;#40;&lt;/span&gt;&lt;span class=&#34;nu0&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sy0&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nu0&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;br0&#34;&gt;&amp;#41;&lt;/span&gt;&lt;span class=&#34;br0&#34;&gt;&amp;#41;&lt;/span&gt;&lt;br /&gt; K&lt;span class=&#34;sy0&#34;&gt;++;&lt;/span&gt;&lt;br /&gt; &lt;br /&gt; &lt;span class=&#34;kw1&#34;&gt;return&lt;/span&gt; K&lt;span class=&#34;sy0&#34;&gt;;&lt;/span&gt;&lt;br /&gt; &lt;span class=&#34;br0&#34;&gt;&amp;#125;&lt;/span&gt;
        &lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;相当与做一次丢硬币的实验，如果遇到正面，继续丢，遇到反面，则停止，&lt;br /&gt;
用实验中丢硬币的次数 K 作为元素占有的层数。显然随机变量 K 满足参数为 p = &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; 的几何分布，&lt;br /&gt;
K 的期望值 E[K] = 1/p = 2. 就是说，各个元素的层数，期望值是 2 层。&lt;/p&gt;

&lt;h4 id=&#34;跳表的高度:2f6491a9cf8eb1ad32d8060eb72d28bc&#34;&gt;跳表的高度&lt;/h4&gt;

&lt;p&gt;n 个元素的跳表，每个元素插入的时候都要做一次实验，用来决定元素占据的层数 K，&lt;br /&gt;
跳表的高度等于这 n 次实验中产生的最大 K，待续。。。&lt;/p&gt;

&lt;h4 id=&#34;跳表的空间复杂度分析:2f6491a9cf8eb1ad32d8060eb72d28bc&#34;&gt;跳表的空间复杂度分析&lt;/h4&gt;

&lt;p&gt;根据上面的分析，每个元素的期望高度为 2， 一个大小为 n 的跳表，其节点数目的&lt;br /&gt;
期望值是 2n。&lt;/p&gt;

&lt;h4 id=&#34;跳表的删除:2f6491a9cf8eb1ad32d8060eb72d28bc&#34;&gt;跳表的删除&lt;/h4&gt;

&lt;p style=&#34;text-align: left;&#34;&gt;
  在各个层中找到包含 x 的节点，使用标准的 delete from list 方法删除该节点。&lt;br /&gt; 例子：删除 71&lt;br /&gt; &lt;img class=&#34;aligncenter  wp-image-1596&#34; title=&#34;7bab9ad1-9f5a-37d0-bc38-89ee50d1bc0d&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/12/7bab9ad1-9f5a-37d0-bc38-89ee50d1bc0d2.jpg&#34; alt=&#34;&#34; width=&#34;625&#34; height=&#34;177&#34; /&gt;
&lt;/p&gt;

&lt;p style=&#34;text-align: left;&#34;&gt;
  原文：&lt;a href=&#34;http://kenby.iteye.com/blog/1187303&#34;&gt;http://kenby.iteye.com/blog/1187303&lt;/a&gt;
&lt;/p&gt;

&lt;p style=&#34;text-align: left;&#34;&gt;
  &amp;#8212;&amp;#8212;
&lt;/p&gt;

&lt;p style=&#34;text-align: left;&#34;&gt;
  比较典型的用空间换取时间的优化算法。
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【转】一致性哈希算法及其在分布式系统中的应用</title>
      <link>http://:1313/tmp/2012/11/%E8%BD%AC%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Thu, 22 Nov 2012 12:43:01 +0000</pubDate>
      
      <guid>http://:1313/tmp/2012/11/%E8%BD%AC%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>

&lt;h4 id=&#34;摘要:d3e80f0bab5d25d1440510f9fdd1ae25&#34;&gt;摘要&lt;/h4&gt;

&lt;p&gt;本文将会从实际应用场景出发，介绍一致性哈希算法（Consistent Hashing）及其在分布式系统中的应用。首先本文会描述一个在日常开发中经常会遇到的问题场景，借此介绍一致性哈希算法以及这个算法如何解决此问题；接下来会对这个算法进行相对详细的描述，并讨论一些如虚拟节点等与此算法应用相关的话题。&lt;/p&gt;

&lt;h4 id=&#34;分布式缓存问题:d3e80f0bab5d25d1440510f9fdd1ae25&#34;&gt;分布式缓存问题&lt;/h4&gt;

&lt;p&gt;假设我们有一个网站，最近发现随着流量增加，服务器压力越来越大，之前直接读写数据库的方式不太给力了，于是我们想引入Memcached作为缓存机制。现在我们一共有三台机器可以作为Memcached服务器，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1567&#34; title=&#34;image8_thumb&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/11/image8_thumb1.png&#34; alt=&#34;&#34; width=&#34;538&#34; height=&#34;346&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;很显然，最简单的策略是将每一次Memcached请求随机发送到一台Memcached服务器，但是这种策略可能会带来两个问题：一是同一份数据可能被存在不同的机器上而造成数据冗余，二是有可能某数据已经被缓存但是访问却没有命中，因为无法保证对相同key的所有访问都被发送到相同的服务器。因此，随机策略无论是时间效率还是空间效率都非常不好。&lt;/p&gt;

&lt;p&gt;要解决上述问题只需做到如下一点：保证对相同key的访问会被发送到相同的服务器。很多方法可以实现这一点，最常用的方法是计算哈希。例如对于每次访问，可以按如下算法计算其哈希值：&lt;/p&gt;

&lt;p&gt;h = Hash(key) % 3&lt;/p&gt;

&lt;p&gt;其中Hash是一个从字符串到正整数的哈希映射函数。这样，如果我们将Memcached Server分别编号为0、1、2，那么就可以根据上式和key计算出服务器编号h，然后去访问。&lt;/p&gt;

&lt;p&gt;这个方法虽然解决了上面提到的两个问题，但是存在一些其它的问题。如果将上述方法抽象，可以认为通过：&lt;/p&gt;

&lt;p&gt;h = Hash(key) % N&lt;/p&gt;

&lt;p&gt;这个算式计算每个key的请求应该被发送到哪台服务器，其中N为服务器的台数，并且服务器按照0 – (N-1)编号。&lt;/p&gt;

&lt;p&gt;这个算法的问题在于容错性和扩展性不好。所谓容错性是指当系统中某一个或几个服务器变得不可用时，整个系统是否可以正确高效运行；而扩展性是指当加入新的服务器后，整个系统是否可以正确高效运行。&lt;/p&gt;

&lt;p&gt;现假设有一台服务器宕机了，那么为了填补空缺，要将宕机的服务器从编号列表中移除，后面的服务器按顺序前移一位并将其编号值减一，此时每个key就要按h = Hash(key) % (N-1)重新计算；同样，如果新增了一台服务器，虽然原有服务器编号不用改变，但是要按h = Hash(key) % (N+1)重新计算哈希值。因此系统中一旦有服务器变更，大量的key会被重定位到不同的服务器从而造成大量的缓存不命中。而这种情况在分布式系统中是非常糟糕的。&lt;/p&gt;

&lt;p&gt;一个设计良好的分布式哈希方案应该具有良好的单调性，即服务节点的增减不会造成大量哈希重定位。一致性哈希算法就是这样一种哈希方案。&lt;/p&gt;

&lt;h4 id=&#34;一致性哈希算法:d3e80f0bab5d25d1440510f9fdd1ae25&#34;&gt;一致性哈希算法&lt;/h4&gt;

&lt;h5 id=&#34;算法简述:d3e80f0bab5d25d1440510f9fdd1ae25&#34;&gt;算法简述&lt;/h5&gt;

&lt;p&gt;一致性哈希算法（Consistent Hashing）最早在论文《&lt;a href=&#34;http://www.akamai.com/dl/technical_publications/ConsistenHashingandRandomTreesDistributedCachingprotocolsforrelievingHotSpotsontheworldwideweb.pdf&#34; target=&#34;_blank&#34;&gt;Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web&lt;/a&gt;》中被提出。简单来说，一致性哈希将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0 &amp;#8211; 2&lt;sup&gt;32&lt;/sup&gt;-1（即哈希值是一个32位无符号整形），整个哈希空间环如下：&lt;/p&gt;

&lt;div id=&#34;attachment_1568&#34; style=&#34;width: 239px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-full wp-image-1568&#34; title=&#34;哈希空间环&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/11/image_thumb1.png&#34; alt=&#34;哈希空间环&#34; width=&#34;229&#34; height=&#34;246&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    哈希空间环
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;整个空间按顺时针方向组织。0和2&lt;sup&gt;32&lt;/sup&gt;-1在零点中方向重合。&lt;/p&gt;

&lt;p&gt;下一步将各个服务器使用H进行一个哈希，具体可以选择服务器的ip或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中三台服务器使用ip地址哈希后在环空间的位置如下：&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1569&#34; title=&#34;image5_thumb&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/11/image5_thumb.png&#34; alt=&#34;&#34; width=&#34;298&#34; height=&#34;248&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数H计算出哈希值h，根据h确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。&lt;/p&gt;

&lt;p&gt;例如我们有A、B、C、D四个数据对象，经过哈希计算后，在环空间上的位置如下：&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1570&#34; title=&#34;image18_thumb1&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/11/image18_thumb1.png&#34; alt=&#34;&#34; width=&#34;299&#34; height=&#34;259&#34; /&gt;&lt;/p&gt;

&lt;p&gt;根据一致性哈希算法，数据A会被定为到Server 1上，D被定为到Server 3上，而B、C分别被定为到Server 2上。&lt;/p&gt;

&lt;h5 id=&#34;容错性与可扩展性分析:d3e80f0bab5d25d1440510f9fdd1ae25&#34;&gt;容错性与可扩展性分析&lt;/h5&gt;

&lt;p&gt;下面分析一致性哈希算法的容错性和可扩展性。现假设Server 3宕机了：&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1571&#34; title=&#34;image23_thumb1&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/11/image23_thumb1.png&#34; alt=&#34;&#34; width=&#34;299&#34; height=&#34;259&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到此时A、C、B不会受到影响，只有D节点被重定位到Server 2。一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即顺着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。&lt;/p&gt;

&lt;p&gt;下面考虑另外一种情况，如果我们在系统中增加一台服务器Memcached Server 4：&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1572&#34; title=&#34;image28_thumb&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/11/image28_thumb.png&#34; alt=&#34;&#34; width=&#34;299&#34; height=&#34;259&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此时A、D、C不受影响，只有B需要重定位到新的Server 4。一般的，在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即顺着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。&lt;/p&gt;

&lt;p&gt;综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。&lt;/p&gt;

&lt;h5 id=&#34;虚拟节点:d3e80f0bab5d25d1440510f9fdd1ae25&#34;&gt;虚拟节点&lt;/h5&gt;

&lt;p&gt;一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。例如我们的系统中有两台服务器，其环分布如下：&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1573&#34; title=&#34;image33_thumb&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/11/image33_thumb.png&#34; alt=&#34;&#34; width=&#34;285&#34; height=&#34;246&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此时必然造成大量数据集中到Server 1上，而只有极少量会定位到Server 2上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器ip或主机名的后面增加编号来实现。例如上面的情况，我们决定为每台服务器计算三个虚拟节点，于是可以分别计算“Memcached Server 1#1”、“Memcached Server 1#2”、“Memcached Server 1#3”、“Memcached Server 2#1”、“Memcached Server 2#2”、“Memcached Server 2#3”的哈希值，于是形成六个虚拟节点：&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1574&#34; title=&#34;image38_thumb&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2012/11/image38_thumb.png&#34; alt=&#34;&#34; width=&#34;341&#34; height=&#34;265&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Memcached Server 1#1”、“Memcached Server 1#2”、“Memcached Server 1#3”三个虚拟节点的数据均定位到Server 1上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。&lt;/p&gt;

&lt;h4 id=&#34;总结:d3e80f0bab5d25d1440510f9fdd1ae25&#34;&gt;总结&lt;/h4&gt;

&lt;p&gt;目前一致性哈希基本成为了分布式系统组件的标准配置，例如Memcached的各种客户端都提供内置的一致性哈希支持。本文只是简要介绍了这个算法，更深入的内容可以参看论文《&lt;a href=&#34;http://www.akamai.com/dl/technical_publications/ConsistenHashingandRandomTreesDistributedCachingprotocolsforrelievingHotSpotsontheworldwideweb.pdf&#34; target=&#34;_blank&#34;&gt;Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web&lt;/a&gt;》，同时提供一个&lt;a href=&#34;http://www.codeproject.com/KB/recipes/lib-conhash.aspx&#34; target=&#34;_blank&#34;&gt;C语言版本的实现&lt;/a&gt;供参考。&lt;/p&gt;

&lt;p&gt;原文网址：&lt;a href=&#34;http://www.codinglabs.org/html/consistent-hashing.html&#34;&gt;http://www.codinglabs.org/html/consistent-hashing.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;#8212;&amp;#8212;&amp;#8211;&lt;/p&gt;

&lt;p&gt;作者已经在文章中介绍的比较清楚了，在这里补充下对“一致性哈希&amp;#8221;这个名词的简单说明，在这个算法中就是指的机器标识符和存储对象采用相同的哈希算法，从而把他们映射到同一个集合（即0-2^32-1的哈希环）。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>