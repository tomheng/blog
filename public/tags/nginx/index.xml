<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nginx on 趣味互联网</title>
    <link>http://:1313/tmp/tags/nginx/</link>
    <description>Recent content in Nginx on 趣味互联网</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 13 Jun 2015 15:06:27 +0000</lastBuildDate>
    <atom:link href="http://:1313/tmp/tags/nginx/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[转]Inside NGINX: How We Designed for Performance &amp;#038; Scale</title>
      <link>http://:1313/tmp/2015/06/%E8%BD%ACinside-nginx-how-we-designed-for-performance-</link>
      <pubDate>Sat, 13 Jun 2015 15:06:27 +0000</pubDate>
      
      <guid>http://:1313/tmp/2015/06/%E8%BD%ACinside-nginx-how-we-designed-for-performance-</guid>
      <description>

&lt;p&gt;NGINX leads the pack in web performance, and it’s all due to the way the software is designed. Whereas many web servers and application servers use a simple threaded or process-based architecture, NGINX stands out with a sophisticated event-driven architecture that enables it to scale to hundreds of thousands of concurrent connections on modern hardware.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;http://nginx.com/resources/library/infographic-inside-nginx/&#34;&gt;Inside NGINX&lt;/a&gt; infographic drills down from the high-level process architecture to illustrate how NGINX handles multiple connections within a single process. This blog explains how it all works in further detail.&lt;/p&gt;

&lt;h2 id=&#34;setting-the-scene-the-nginx-process-model:19032429da545135790f588d1d3e4370&#34;&gt;Setting the Scene – the NGINX Process Model&lt;/h2&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1939&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2015/06/Screen-Shot-2015-06-08-at-12.36.30-PM.png&#34; alt=&#34;Screen-Shot-2015-06-08-at-12.36.30-PM&#34; width=&#34;740&#34; height=&#34;439&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To better understand this design, you need to understand how NGINX runs. NGINX has a master process (which performs the privileged operations such as reading configuration and binding to ports) and a number of worker and helper processes.&lt;/p&gt;

&lt;div class=&#34;codecolorer-container bash blackboard&#34; style=&#34;overflow:auto;white-space:nowrap;&#34;&gt;
  &lt;table cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;
    &lt;tr&gt;
      &lt;td class=&#34;line-numbers&#34;&gt;
        &lt;div&gt;
          1&lt;br /&gt;2&lt;br /&gt;3&lt;br /&gt;4&lt;br /&gt;5&lt;br /&gt;6&lt;br /&gt;7&lt;br /&gt;8&lt;br /&gt;9&lt;br /&gt;10&lt;br /&gt;11&lt;br /&gt;
        &lt;/div&gt;
      &lt;/td&gt;
      
      &lt;td&gt;
        &lt;div class=&#34;bash codecolorer&#34;&gt;
          &lt;span class=&#34;co0&#34;&gt;# service nginx restart&lt;/span&gt;&lt;br /&gt; &lt;span class=&#34;sy0&#34;&gt;*&lt;/span&gt; Restarting nginx&lt;br /&gt; &lt;span class=&#34;co0&#34;&gt;# ps -ef --forest | grep nginx&lt;/span&gt;&lt;br /&gt; root &lt;span class=&#34;nu0&#34;&gt;32475&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;13&lt;/span&gt;:&lt;span class=&#34;nu0&#34;&gt;36&lt;/span&gt; ? 00:00:00 nginx: master process &lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;usr&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;sbin&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;nginx \&lt;br /&gt; &lt;span class=&#34;re5&#34;&gt;-c&lt;/span&gt; &lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;etc&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;nginx&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;nginx.conf&lt;br /&gt; nginx &lt;span class=&#34;nu0&#34;&gt;32476&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;32475&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;13&lt;/span&gt;:&lt;span class=&#34;nu0&#34;&gt;36&lt;/span&gt; ? 00:00:00 \_ nginx: worker process&lt;br /&gt; nginx &lt;span class=&#34;nu0&#34;&gt;32477&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;32475&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;13&lt;/span&gt;:&lt;span class=&#34;nu0&#34;&gt;36&lt;/span&gt; ? 00:00:00 \_ nginx: worker process&lt;br /&gt; nginx &lt;span class=&#34;nu0&#34;&gt;32479&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;32475&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;13&lt;/span&gt;:&lt;span class=&#34;nu0&#34;&gt;36&lt;/span&gt; ? 00:00:00 \_ nginx: worker process&lt;br /&gt; nginx &lt;span class=&#34;nu0&#34;&gt;32480&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;32475&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;13&lt;/span&gt;:&lt;span class=&#34;nu0&#34;&gt;36&lt;/span&gt; ? 00:00:00 \_ nginx: worker process&lt;br /&gt; nginx &lt;span class=&#34;nu0&#34;&gt;32481&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;32475&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;13&lt;/span&gt;:&lt;span class=&#34;nu0&#34;&gt;36&lt;/span&gt; ? 00:00:00 \_ nginx: cache manager process&lt;br /&gt; nginx &lt;span class=&#34;nu0&#34;&gt;32482&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;32475&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;&lt;/span&gt; &lt;span class=&#34;nu0&#34;&gt;13&lt;/span&gt;:&lt;span class=&#34;nu0&#34;&gt;36&lt;/span&gt; ? 00:00:00 \_ nginx: cache loader process
        &lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;On this 4-core server, the NGINX master process creates 4 worker processes and a couple of cache helper processes which manage the on-disk content cache.&lt;/p&gt;

&lt;h2 id=&#34;why-is-architecture-important:19032429da545135790f588d1d3e4370&#34;&gt;Why Is Architecture Important?&lt;/h2&gt;

&lt;p&gt;The fundamental basis of any Unix application is the thread or process. (From the Linux OS perspective, threads and processes are mostly identical; the major difference is the degree to which they share memory.) A thread or process is a self-contained set of instructions that the operating system can schedule to run on a CPU core. Most complex applications run multiple threads or processes in parallel for two reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They can use more compute cores at the same time.&lt;/li&gt;
&lt;li&gt;Threads and processes make it very easy to do operations in parallel (for example, to handle multiple connections at the same time).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Processes and threads consume resources. They each use memory and other OS resources, and they need to be swapped on and off the cores (an operation called a &lt;em&gt;context switch&lt;/em&gt;). Most modern servers can handle hundreds of small, active threads or processes simultaneously, but performance degrades seriously once memory is exhausted or when high I/O load causes a large volume of context switches.&lt;/p&gt;

&lt;p&gt;The common way to design network applications is to assign a thread or process to each connection. This architecture is simple and easy to implement, but it does not scale when the application needs to handle thousands of simultaneous connections.&lt;/p&gt;

&lt;h2 id=&#34;how-does-nginx-work:19032429da545135790f588d1d3e4370&#34;&gt;How Does NGINX Work?&lt;/h2&gt;

&lt;p&gt;NGINX uses a predictable process model that is tuned to the available hardware resources:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;master&lt;/em&gt; process performs the privileged operations such as reading configuration and binding to ports, and then creates a small number of child processes (the next three types).&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;cache loader&lt;/em&gt; process runs at startup to load the disk-based cache into memory, and then exits. It is scheduled conservatively, so its resource demands are low.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;cache manager&lt;/em&gt; process runs periodically and prunes entries from the disk caches to keep them within the configured sizes.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;worker&lt;/em&gt; processes do all of the work! They handle network connections, read and write content to disk, and communicate with upstream servers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The NGINX configuration recommended in most cases – running one worker process per CPU core – makes the most efficient use of hardware resources. You configure it by including the &lt;a href=&#34;http://nginx.org/en/docs/ngx_core_module.html#worker_processes&#34; target=&#34;_blank&#34;&gt;worker_processes auto&lt;/a&gt; directive in the configuration:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;worker_processes auto;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When an NGINX server is active, only the worker processes are busy. Each worker process handles multiple connections in a non-blocking fashion, reducing the number of context switches.&lt;/p&gt;

&lt;p&gt;Each worker process is single-threaded and runs independently, grabbing new connections and processing them. The processes can communicate using shared memory for shared cache data, session persistence data, and other shared resources.&lt;/p&gt;

&lt;h2 id=&#34;inside-the-nginx-worker-process:19032429da545135790f588d1d3e4370&#34;&gt;Inside the NGINX Worker Process&lt;/h2&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1940&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2015/06/Screen-Shot-2015-06-08-at-12.39.48-PM.png&#34; alt=&#34;Screen-Shot-2015-06-08-at-12.39.48-PM&#34; width=&#34;866&#34; height=&#34;405&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Each NGINX worker process is initialized with the NGINX configuration and is provided with a set of listen sockets by the master process.&lt;/p&gt;

&lt;p&gt;The NGINX worker processes begin by waiting for events on the listen sockets (&lt;a href=&#34;http://nginx.org/en/docs/ngx_core_module.html#accept_mutex&#34; target=&#34;_blank&#34;&gt;accept_mutex&lt;/a&gt; and &lt;a href=&#34;http://nginx.com/blog/socket-sharding-nginx-release-1-9-1/&#34; target=&#34;_blank&#34;&gt;kernel socket sharding&lt;/a&gt;). Events are initiated by new incoming connections. These connections are assigned to a *state machine* – the HTTP state machine is the most commonly used, but NGINX also implements state machines for stream (raw TCP) traffic and for a number of mail protocols (SMTP, IMAP, and POP3).&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1941&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2015/06/Screen-Shot-2015-06-08-at-12.40.32-PM.png&#34; alt=&#34;Screen-Shot-2015-06-08-at-12.40.32-PM&#34; width=&#34;703&#34; height=&#34;742&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The state machine is essentially the set of instructions that tell NGINX how to process a request. Most web servers that perform the same functions as NGINX use a similar state machine – the difference lies in the implementation.&lt;/p&gt;

&lt;h2 id=&#34;scheduling-the-state-machine:19032429da545135790f588d1d3e4370&#34;&gt;Scheduling the State Machine&lt;/h2&gt;

&lt;p&gt;Think of the state machine like the rules for chess. Each HTTP transaction is a chess game. On one side of the chessboard is the web server – a grandmaster who can make decisions very quickly. On the other side is the remote client – the web browser that is accessing the site or application over a relatively slow network.&lt;/p&gt;

&lt;p&gt;However, the rules of the game can be very complicated. For example, the web server might need to communicate with other parties (proxying to an upstream application) or talk to an authentication server. Third-party modules in the web server can even extend the rules of the game.&lt;/p&gt;

&lt;h3 id=&#34;a-blocking-state-machine:19032429da545135790f588d1d3e4370&#34;&gt;A Blocking State Machine&lt;/h3&gt;

&lt;p&gt;Recall our description of a process or thread as a self-contained set of instructions that the operating system can schedule to run on a CPU core. Most web servers and web applications use a process-per-connection orthread-per-connection model to play the chess game. Each process or thread contains the instructions to play one game through to the end. During the time the process is run by the server, it spends most of its time ‘blocked’ – waiting for the client to complete its next move.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1942&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2015/06/Screen-Shot-2015-06-08-at-12.40.52-PM.png&#34; alt=&#34;Screen-Shot-2015-06-08-at-12.40.52-PM&#34; width=&#34;373&#34; height=&#34;341&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The web server process listens for new connections (new games initiated by clients) on the listen sockets.&lt;/li&gt;
&lt;li&gt;When it gets a new game, it plays that game, blocking after each move to wait for the client’s response.&lt;/li&gt;
&lt;li&gt;Once the game completes, the web server process might wait to see if the client wants to start a new game (this corresponds to a keepalive connection). If the connection is closed (the client goes away or a timeout occurs), the web server process returns to listening for new games.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The important point to remember is that every active HTTP connection (every chess game) requires a dedicated process or thread (a grandmaster). This architecture is simple and easy to extend with third-party modules (‘new rules’). However, there’s a huge imbalance: the rather lightweight HTTP connection, represented by a file descriptor and a small amount of memory, maps to a separate thread or process, a very heavyweight operating system object. It’s a programming convenience, but it’s massively wasteful.&lt;/p&gt;

&lt;h3 id=&#34;nginx-is-a-true-grandmaster:19032429da545135790f588d1d3e4370&#34;&gt;NGINX is a True Grandmaster&lt;/h3&gt;

&lt;p&gt;Perhaps you’ve heard of &lt;a href=&#34;http://en.wikipedia.org/wiki/Simultaneous_exhibition&#34; target=&#34;_blank&#34;&gt;simultaneous exhibition&lt;/a&gt; games, where one chess grandmaster plays dozens of opponents at the same time?&lt;/p&gt;

&lt;div id=&#34;attachment_1943&#34; style=&#34;width: 490px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;wp-image-1943 size-full&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2015/06/Kiril-Georgiev.gif&#34; alt=&#34;Kiril-Georgiev&#34; width=&#34;480&#34; height=&#34;337&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Kiril Georgiev played 360 people simultaneously in Sofia, Bulgaria. His final score was 284 wins, 70 draws and 6 losses.
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;That’s how an NGINX worker process plays “chess.” Each worker (remember – there’s usually one worker for each CPU core) is a grandmaster that can play hundreds (in fact, hundreds of thousands) of games simultaneously.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1944&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2015/06/Screen-Shot-2015-06-08-at-12.41.13-PM.png&#34; alt=&#34;Screen-Shot-2015-06-08-at-12.41.13-PM&#34; width=&#34;376&#34; height=&#34;355&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The worker waits for events on the listen and connection sockets.&lt;/li&gt;
&lt;li&gt;Events occur on the sockets and the worker handles them:

&lt;ul&gt;
&lt;li&gt;An event on the listen socket means that a client has started a new chess game. The worker creates a new connection socket.&lt;/li&gt;
&lt;li&gt;An event on a connection socket means that the client has made a new move. The worker responds promptly.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A worker never blocks on network traffic, waiting for its “opponent” (the client) to respond. When it has made its move, the worker immediately proceeds to other games where moves are waiting to be processed, or welcomes new players in the door.&lt;/p&gt;

&lt;h3 id=&#34;why-is-this-faster-than-a-blocking-multi-process-architecture:19032429da545135790f588d1d3e4370&#34;&gt; Why Is This Faster than a Blocking, Multi-Process Architecture?&lt;/h3&gt;

&lt;p&gt;NGINX scales very well to support hundreds of thousands of connections per worker process. Each new connection creates another file descriptor and consumes a small amount of additional memory in the worker process. There is very little additional overhead per connection. NGINX processes can remain pinned to CPUs. Context switches are relatively infrequent and occur when there is no work to be done.&lt;/p&gt;

&lt;p&gt;In the blocking, connection-per-process approach, each connection requires a large amount of additional resources and overhead, and context switches (swapping from one process to another) are very frequent.&lt;/p&gt;

&lt;p&gt;For a more detailed explanation, check out this &lt;a href=&#34;http://www.aosabook.org/en/nginx.html&#34; target=&#34;_blank&#34;&gt;article&lt;/a&gt; about NGINX architecture, by Andrew Alexeev, VP of Corporate Development and Co-Founder at NGINX, Inc.&lt;/p&gt;

&lt;p&gt;With appropriate &lt;a href=&#34;http://nginx.com/blog/tuning-nginx/&#34;&gt;system tuning&lt;/a&gt;, NGINX can scale to handle hundreds of thousands of concurrent HTTP connections per worker process, and can absorb traffic spikes (an influx of new games) without missing a beat.&lt;/p&gt;

&lt;h2 id=&#34;updating-configuration-and-upgrading-nginx:19032429da545135790f588d1d3e4370&#34;&gt;Updating Configuration and Upgrading NGINX&lt;/h2&gt;

&lt;p&gt;NGINX’s process architecture, with a small number of worker processes, makes for very efficient updating of the configuration and even the NGINX binary itself.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1945&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2015/06/Screen-Shot-2015-06-08-at-12.41.33-PM.png&#34; alt=&#34;Screen-Shot-2015-06-08-at-12.41.33-PM&#34; width=&#34;729&#34; height=&#34;305&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Updating NGINX configuration is a very simple, lightweight, and reliable operation. It typically just means running the&lt;/p&gt;

&lt;div class=&#34;codecolorer-container bash blackboard&#34; style=&#34;overflow:auto;white-space:nowrap;&#34;&gt;
  &lt;table cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;
    &lt;tr&gt;
      &lt;td class=&#34;line-numbers&#34;&gt;
        &lt;div&gt;
          1&lt;br /&gt;
        &lt;/div&gt;
      &lt;/td&gt;
      
      &lt;td&gt;
        &lt;div class=&#34;bash codecolorer&#34;&gt;
          nginx –s reload
        &lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;command, which checks the configuration on disk and sends the master process a SIGHUP signal.&lt;/p&gt;

&lt;p&gt;When the master process receives a SIGHUP, it does two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Reloads the configuration and forks a new set of worker processes. These new worker processes immediately begin accepting connections and processing traffic (using the new configuration settings).&lt;/li&gt;
&lt;li&gt;Signals the old worker processes to gracefully exit. The worker processes stop accepting new connections. As soon as each current HTTP request completes, the worker process cleanly shuts down the connection (that is, there are no lingering keepalives). Once all connections are closed, the worker processes exit.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This reload process can cause a small spike in CPU and memory usage, but it’s generally imperceptible compared to the resource load from active connections. You can reload the configuration multiple times per second (and many NGINX users do exactly that). Very rarely, issues arise when there are many generations of NGINX worker processes waiting for connections to close, but even those are quickly resolved.&lt;/p&gt;

&lt;p&gt;NGINX’s binary upgrade process achieves the holy grail of high-availability – you can upgrade the software on the fly, without any dropped connections, downtime, or interruption in service.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-1946&#34; src=&#34;http://blog.webfuns.net/wp-content/uploads/2015/06/Screen-Shot-2015-06-08-at-12.41.51-PM.png&#34; alt=&#34;Screen-Shot-2015-06-08-at-12.41.51-PM&#34; width=&#34;774&#34; height=&#34;284&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The binary upgrade process is similar in approach to the graceful reload of configuration. A new NGINX master process runs in parallel with the original master process, and they share the listening sockets. Both processes are active, and their respective worker processes handle traffic. You can then signal the old master and its workers to gracefully exit.&lt;/p&gt;

&lt;p&gt;The entire process is described in more detail in &lt;a href=&#34;http://nginx.org/en/docs/control.html&#34; target=&#34;_blank&#34;&gt;Controlling NGINX&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:19032429da545135790f588d1d3e4370&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;http://nginx.com/resources/library/infographic-inside-nginx/&#34;&gt;Inside NGINX infographic&lt;/a&gt; provides a high-level overview of how NGINX functions, but behind this simple explanation is over ten years of innovation and optimization that enable NGINX to deliver the best possible performance on a wide range of hardware while maintaining the security and reliability that modern web applications require.&lt;/p&gt;

&lt;p&gt;If you’d like to read more about the optimizations in NGINX, check out these great resources:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://nginx.com/resources/webinars/installing-tuning-nginx/&#34;&gt;Installing and Tuning NGINX for Performance&lt;/a&gt; (webinar; &lt;a href=&#34;https://speakerdeck.com/nginx/nginx-installation-and-tuning&#34; target=&#34;_blank&#34;&gt;slides&lt;/a&gt; at Speaker Deck)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nginx.com/blog/tuning-nginx/&#34;&gt;Tuning NGINX for Performance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.aosabook.org/en/nginx.html&#34; target=&#34;_blank&#34;&gt;The Architecture of Open Source Applications – NGINX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nginx.com/blog/socket-sharding-nginx-release-1-9-1/&#34;&gt;Socket Sharding in NGINX Release 1.9.1&lt;/a&gt; (using the SO_REUSEPORT socket option)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原文：&lt;a href=&#34;http://nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/&#34;&gt;http://nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nginx 泛域名配置</title>
      <link>http://:1313/tmp/2014/09/nginx-%E6%B3%9B%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Thu, 04 Sep 2014 06:20:35 +0000</pubDate>
      
      <guid>http://:1313/tmp/2014/09/nginx-%E6%B3%9B%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE/</guid>
      <description>&lt;p&gt;泛域名的应用比较广泛，比如实现二级域名的无限支持、&lt;span style=&#34;color: #333333;&#34;&gt;免费的URL转发等。在开发中，如果团队中多个成员须测试同一套代码，那么就会出现彼此覆盖冲突的问题。这个时候就可以用泛域名将不同的域名指向到不同的目录，这样就不会彼此干扰了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;相关配置如下&lt;/p&gt;

&lt;div class=&#34;codecolorer-container bash blackboard&#34; style=&#34;overflow:auto;white-space:nowrap;&#34;&gt;
  &lt;table cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;
    &lt;tr&gt;
      &lt;td class=&#34;line-numbers&#34;&gt;
        &lt;div&gt;
          1&lt;br /&gt;2&lt;br /&gt;3&lt;br /&gt;4&lt;br /&gt;5&lt;br /&gt;6&lt;br /&gt;7&lt;br /&gt;8&lt;br /&gt;9&lt;br /&gt;
        &lt;/div&gt;
      &lt;/td&gt;
      
      &lt;td&gt;
        &lt;div class=&#34;bash codecolorer&#34;&gt;
          server&lt;br /&gt; &lt;span class=&#34;br0&#34;&gt;&amp;#123;&lt;/span&gt;&lt;br /&gt; &amp;nbsp; &amp;nbsp;&lt;span class=&#34;kw1&#34;&gt;set&lt;/span&gt; &lt;span class=&#34;re1&#34;&gt;$domain&lt;/span&gt; &lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;data1&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;apache&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;share&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;htdocs&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;kw3&#34;&gt;test&lt;/span&gt;;&lt;br /&gt; &amp;nbsp; &amp;nbsp;&lt;span class=&#34;kw1&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;br0&#34;&gt;&amp;#40;&lt;/span&gt;&lt;span class=&#34;re1&#34;&gt;$http_host&lt;/span&gt; ~&lt;span class=&#34;sy0&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;st0&#34;&gt;&#34;^(.*)\.test\.com$&#34;&lt;/span&gt;&lt;span class=&#34;br0&#34;&gt;&amp;#41;&lt;/span&gt;&lt;br /&gt; &amp;nbsp; &amp;nbsp;&lt;span class=&#34;br0&#34;&gt;&amp;#123;&lt;/span&gt;&lt;br /&gt; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;span class=&#34;kw1&#34;&gt;set&lt;/span&gt; &lt;span class=&#34;re1&#34;&gt;$domain&lt;/span&gt; &lt;span class=&#34;re4&#34;&gt;$1&lt;/span&gt;;&lt;br /&gt; &amp;nbsp; &amp;nbsp;&lt;span class=&#34;br0&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br /&gt; &amp;nbsp; &amp;nbsp;root &lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;usr&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;home&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;re1&#34;&gt;$domain&lt;/span&gt;&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;kw3&#34;&gt;test&lt;/span&gt;;&lt;br /&gt; &lt;span class=&#34;br0&#34;&gt;&amp;#125;&lt;/span&gt;
        &lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;这样A开发可以用a.test.com , B开可以用b.test.com 。&lt;/p&gt;

&lt;p&gt;&amp;#8211;done&amp;#8211;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>小网站也可以用上自己的HTTPS</title>
      <link>http://:1313/tmp/2013/12/%E5%B0%8F%E7%BD%91%E7%AB%99%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%B8%8A%E8%87%AA%E5%B7%B1%E7%9A%84https/</link>
      <pubDate>Tue, 24 Dec 2013 14:00:53 +0000</pubDate>
      
      <guid>http://:1313/tmp/2013/12/%E5%B0%8F%E7%BD%91%E7%AB%99%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%B8%8A%E8%87%AA%E5%B7%B1%E7%9A%84https/</guid>
      <description>&lt;p&gt;自己周末吓折腾一番，总结下分享出来，希望对大家有用。&lt;/p&gt;

&lt;p&gt;其实就两步就可以完成，超简单的哦～&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1）申请证书&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个一般正规网站都用收费的证书，小网站或者像我这样的博客就没有必要用收费证书了。我选择了&lt;a href=&#34;http://www.startssl.com/&#34;&gt;StartSSL&lt;/a&gt;,申请的时候按照网站的说明一步步来有七八分钟就能够拿到证书，如果实在搞不定可以看看这个&lt;a href=&#34;http://www.deepvps.com/apply-startssl-ssl-certificate.html&#34;&gt;说明&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;请注意，从StartSSL申请的免费证书只有一年的有效期。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2）在服务器上安装证书&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所谓的证书就是一个字符串，这个上传到服务器指定目录，然后配置下服务器就可以了。如果是nginx可以参看&lt;a href=&#34;http://www.startssl.com/?app=42&#34;&gt;http://www.startssl.com/?app=42&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下面是我的服务器配置，顺便支持了SPDY。&lt;/p&gt;

&lt;div class=&#34;codecolorer-container bash blackboard&#34; style=&#34;overflow:auto;white-space:nowrap;&#34;&gt;
  &lt;table cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;
    &lt;tr&gt;
      &lt;td class=&#34;line-numbers&#34;&gt;
        &lt;div&gt;
          1&lt;br /&gt;2&lt;br /&gt;3&lt;br /&gt;4&lt;br /&gt;5&lt;br /&gt;6&lt;br /&gt;7&lt;br /&gt;8&lt;br /&gt;9&lt;br /&gt;
        &lt;/div&gt;
      &lt;/td&gt;
      
      &lt;td&gt;
        &lt;div class=&#34;bash codecolorer&#34;&gt;
          server &lt;span class=&#34;br0&#34;&gt;&amp;#123;&lt;/span&gt;&lt;br /&gt; &amp;nbsp; &amp;nbsp; listen &lt;span class=&#34;nu0&#34;&gt;443&lt;/span&gt; ssl spdy;&lt;br /&gt; &amp;nbsp; &amp;nbsp; server_name blog.webfuns.net;&lt;br /&gt; &amp;nbsp; &amp;nbsp; root &amp;nbsp; &lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;var&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;www&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;blog&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;;&lt;br /&gt; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ssl on;&lt;br /&gt; &amp;nbsp; &amp;nbsp; ssl_certificate &lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;etc&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;nginx&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;certs&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;ssl-unified.crt;&lt;br /&gt; &amp;nbsp; &amp;nbsp; ssl_certificate_key &lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;etc&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;nginx&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;certs&lt;span class=&#34;sy0&#34;&gt;/&lt;/span&gt;server.key;&lt;br /&gt; &amp;nbsp; &amp;nbsp; index &amp;nbsp;index.html index.htm index.php;&lt;br /&gt; &lt;span class=&#34;br0&#34;&gt;&amp;#125;&lt;/span&gt;
        &lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;接下来把服务器重启下就可以啦，打开浏览器试试&lt;a href=&#34;https://blog.webfuns.net&#34;&gt;https://blog.webfuns.net&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;顺祝大家圣诞快乐～&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>